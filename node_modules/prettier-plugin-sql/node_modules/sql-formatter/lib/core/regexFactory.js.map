{"version":3,"sources":["../../src/core/regexFactory.ts"],"names":["createOperatorRegex","monadOperators","polyadOperators","RegExp","map","escapeRegExp","join","split","createLineCommentRegex","lineCommentTypes","c","createReservedWordRegex","reservedKeywords","specialWordChars","length","reservedKeywordsPattern","replace","createWordRegex","specialChars","prefixLookBehind","prefix","suffixLookAhead","suffix","unicodeWordChar","any","arrayAccessor","mapAccessor","patterns","createStringPattern","stringTypes","t","createStringRegex","escapeParen","paren","createParenRegex","parens","createPlaceholderRegex","types","pattern","undefined","typesRegex"],"mappings":"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","sourcesContent":["import { escapeRegExp, isEmpty, sortByLengthDesc } from 'src/utils';\n\n/**\n * Builds a RegExp containing all operators for a SQL dialect\n * @param {string} monadOperators - concatenated string of all 1-length operators\n * @param {string[]} polyadOperators - list of strings of all >1-length operators\n */\nexport const createOperatorRegex = (monadOperators: string, polyadOperators: string[]): RegExp =>\n  new RegExp(\n    `^(${sortByLengthDesc(polyadOperators).map(escapeRegExp).join('|')}|` +\n      `[${monadOperators.split('').map(escapeRegExp).join('')}])`,\n    'u'\n  );\n\n/**\n * Builds a RegExp for valid line comments in a SQL dialect\n * @param {string[]} lineCommentTypes - list of character strings that denote line comments\n */\nexport const createLineCommentRegex = (lineCommentTypes: string[]): RegExp =>\n  new RegExp(\n    `^((?:${lineCommentTypes.map(c => escapeRegExp(c)).join('|')}).*?)(?:\\r\\n|\\r|\\n|$)`,\n    'u'\n  );\n\n/**\n * Builds a RegExp for all Reserved Keywords in a SQL dialect\n * @param {string[]} reservedKeywords - list of strings of all Reserved Keywords\n * @param {string} specialWordChars - concatenated string of all special chars that can appear in valid identifiers (and not in Reserved Keywords)\n */\nexport const createReservedWordRegex = (\n  reservedKeywords: string[],\n  specialWordChars: string = ''\n): RegExp => {\n  if (reservedKeywords.length === 0) {\n    return /^\\b$/u;\n  }\n  const reservedKeywordsPattern = sortByLengthDesc(reservedKeywords)\n    .join('|')\n    .replace(/ /gu, '\\\\s+');\n  return new RegExp(\n    `^(${reservedKeywordsPattern})(?![${escapeRegExp(specialWordChars)}]+)\\\\b`,\n    'iu'\n  );\n};\n\n/**\n * Builds a RegExp for valid identifiers in a SQL dialect\n * @param {Object} specialChars\n * @param {string} specialChars.any - concatenated string of chars that can appear anywhere in a valid identifier\n * @param {string} specialChars.prefix - concatenated string of chars that only appear at the beginning of a valid identifier\n * @param {string} specialChars.suffix - concatenated string of chars that only appear at the end of a valid identifier\n */\nexport const createWordRegex = (\n  specialChars: { any?: string; prefix?: string; suffix?: string } = {}\n): RegExp => {\n  const prefixLookBehind = `[${escapeRegExp(specialChars.prefix ?? '')}]*`;\n  const suffixLookAhead = `[${escapeRegExp(specialChars.suffix ?? '')}]*`;\n  const unicodeWordChar =\n    '\\\\p{Alphabetic}\\\\p{Mark}\\\\p{Decimal_Number}\\\\p{Connector_Punctuation}\\\\p{Join_Control}';\n  const specialWordChars = `${escapeRegExp(specialChars.any ?? '')}`;\n\n  const arrayAccessor = '\\\\[\\\\d\\\\]';\n  const mapAccessor = `\\\\[['\"][${unicodeWordChar}]+['\"]\\\\]`;\n\n  return new RegExp(\n    `^((${prefixLookBehind}([${unicodeWordChar}${specialWordChars}]+)${suffixLookAhead})(${arrayAccessor}|${mapAccessor})?)`,\n    'u'\n  );\n};\n\n// This enables the following string patterns:\n// 1. backtick quoted string using `` to escape\n// 2. square bracket quoted string (SQL Server) using ]] to escape\n// 3. double quoted string using \"\" or \\\" to escape\n// 4. single quoted string using '' or \\' to escape\n// 5. national character quoted string using N'' or N\\' to escape\n// 6. Unicode single-quoted string using \\' to escape\n// 7. Unicode double-quoted string using \\\" to escape\n// 8. PostgreSQL dollar-quoted strings\nconst patterns = {\n  '``': '((`[^`]*($|`))+)',\n  '{}': '((\\\\{[^\\\\}]*($|\\\\}))+)',\n  '[]': '((\\\\[[^\\\\]]*($|\\\\]))(\\\\][^\\\\]]*($|\\\\]))*)',\n  '\"\"': '((\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+)',\n  \"''\": \"(('[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n  \"N''\": \"((N'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n  \"x''\": \"(([xX]'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n  \"E''\": \"((E'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n  \"U&''\": \"((U&'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n  'U&\"\"': '((U&\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+)',\n  '$$': '((?<tag>\\\\$\\\\w*\\\\$)[\\\\s\\\\S]*?(?:\\\\k<tag>|$))',\n};\nexport type StringPatternType = keyof typeof patterns;\n\n/**\n * Builds a string pattern for matching string patterns for all given string types\n * @param {StringPatternType[]} stringTypes - list of strings that denote string patterns\n */\nexport const createStringPattern = (stringTypes: StringPatternType[]): string =>\n  stringTypes.map(t => patterns[t]).join('|');\n\n/**\n * Builds a RegExp for matching string patterns using `createStringPattern`\n * @param {StringPatternType[]} stringTypes - list of strings that denote string patterns\n */\nexport const createStringRegex = (stringTypes: StringPatternType[]): RegExp =>\n  new RegExp('^(' + createStringPattern(stringTypes) + ')', 'u');\n\n/** Escapes paren characters for RegExp patterns */\nconst escapeParen = (paren: string): string => {\n  if (paren.length === 1) {\n    // A single punctuation character\n    return escapeRegExp(paren);\n  } else {\n    // longer word\n    return '\\\\b' + paren + '\\\\b';\n  }\n};\n\n/**\n * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`\n * @param {string[]} parens - list of strings that denote parenthesis patterns\n */\nexport const createParenRegex = (parens: string[]): RegExp =>\n  new RegExp('^(' + parens.map(escapeParen).join('|') + ')', 'iu');\n\n/**\n * Builds a RegExp for placeholder patterns\n * @param {string[]} types - list of strings that denote placeholder types\n * @param {string} pattern - string that denotes placeholder pattern\n */\nexport const createPlaceholderRegex = (types: string[], pattern: string): RegExp | undefined => {\n  if (isEmpty(types)) {\n    return undefined;\n  }\n  const typesRegex = types.map(escapeRegExp).join('|');\n\n  return new RegExp(`^((?:${typesRegex})(?:${pattern}))`, 'u');\n};\n"],"file":"regexFactory.js"}